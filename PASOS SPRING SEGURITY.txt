Estos son los paso de mi proyecto de primer app:

ðŸ”¹ Paso 1 â€“ El usuario abre el formulario

Archivo: login.html

El usuario escribe username y password y pulsa Login.

Esto envÃ­a una peticiÃ³n POST a /login gracias a:

<form th:action="@{/login}" method="post">


TodavÃ­a aquÃ­ no pasa por ningÃºn controlador tuyo, porque /login estÃ¡ interceptado por Spring Security.

ðŸ”¹ Paso 2 â€“ IntercepciÃ³n de /login por Spring Security

Archivo: WebSecurityConfing.java

En este bean:

.formLogin(form -> form
    .loginPage("/login")
    .permitAll())


le dices a Spring:

Usa mi plantilla login.html para mostrar el formulario.

Cuando llegue un POST a /login, maneja tÃº la autenticaciÃ³n.

AquÃ­ entra en juego el Security Filter Chain: un conjunto de filtros que procesan la solicitud antes de llegar a cualquier @Controller.

ðŸ”¹ Paso 3 â€“ Spring Security extrae credenciales

Del POST a /login, Spring Security obtiene:

username = lo_que_escribiste
password = lo_que_escribiste


Llama al AuthenticationManager, que en tu configuraciÃ³n estÃ¡ ajustado para usar JDBC.

ðŸ”¹ Paso 4 â€“ Consulta JDBC a la BD

En WebSecurityConfing.configAuthentication configuraste:

builder.jdbcAuthentication()
    .passwordEncoder(new BCryptPasswordEncoder())
    .dataSource(dataSource)
    .usersByUsernameQuery("select username, password, enabled from users where username=?")
    .authoritiesByUsernameQuery("select username, role from users where username=?");


Esto significa:

Busca el usuario en la tabla users con la primera consulta.
Ejemplo:

select username, password, enabled 
from users 
where username = 'juan';


Obtiene su password (hash BCrypt), su estado enabled y luego su role con la segunda consulta.

ðŸ”¹ Paso 5 â€“ VerificaciÃ³n de contraseÃ±a con BCrypt

Spring toma:

Lo que escribiÃ³ el usuario (rawPassword)

El hash de la BD ($2a$10$zqrrflfjI3ghQ2u5qFPw7uBgbKCYUWnAxUt4YJMr9xrRH3ex60qk2)

Usa:

new BCryptPasswordEncoder().matches(rawPassword, passwordHashDeLaBD)


Si coincide â†’ autenticaciÃ³n exitosa.

Si no coincide â†’ redirige a /login?error.

ðŸ”¹ Paso 6 â€“ CreaciÃ³n de la sesiÃ³n

Si la contraseÃ±a es correcta y enabled = true, Spring Security:

Crea un Authentication con tu usuario y roles.

Lo guarda en el SecurityContext.

Abre una sesiÃ³n HTTP para mantenerte logueado.

ðŸ”¹ Paso 7 â€“ RedirecciÃ³n a la pÃ¡gina solicitada

Si el usuario intentaba acceder a algo protegido, lo redirige ahÃ­ despuÃ©s de login.

Si no, lo manda a la pÃ¡gina por defecto que hayas configurado (en tu caso no hay una explÃ­cita, asÃ­ que va a la raÃ­z / o a /personas si la pides).

ðŸ”¹ Paso 8 â€“ Acceso a rutas protegidas

Gracias a:

.requestMatchers("/personas/nueva").hasAnyRole("ADMIN")
.anyRequest().authenticated()


Spring valida tus roles antes de entrar a los controladores como PersonaController.

Si no tienes permiso â†’ te manda a 403.html (configurado en WebMvcConfigurer).

ðŸ“Œ Â¿Y el SecuredPassword?

Tu clase:

public class SecuredPassword {
    public static void main(String[] args) {
        BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();
        String encodedPassword = encoder.encode("password");
        System.out.println(encodedPassword);
    }
}


solo sirve para generar hashes manualmente e insertarlos en la BD cuando no tienes registro automÃ¡tico de usuarios.

No participa en el login: es solo una herramienta de prueba.